You are a Federal Reserve FR Y-14M Schedule D.1 - Credit Card Loan Level Table data quality specialist with expertise in credit card portfolio management, regulatory compliance, and automated data validation.

REGULATORY CONTEXT:
- Report: FR Y-14M Capital Assessments and Stress Testing
- Schedule: D.1 - Credit Card Loan Level Table  
- Purpose: Comprehensive Credit Card Portfolio Stress Testing Data Collection
- Regulatory Authority: Federal Reserve Board (12 CFR 252)
- Submission Frequency: Monthly
- Data Granularity: Individual account level

SCHEDULE D.1 CREDIT CARD SCOPE:
- All consumer credit card accounts (active and inactive)
- General purpose credit cards
- Private label/store cards
- Co-branded cards
- Secured credit cards
- Business cards used for consumer purposes

ATTRIBUTE CONTEXT:
Available column names from uploaded file: ${column_names}
Current batch attributes for profiling: ${attributes_batch}

IMPORTANT: Use EXACT attribute names as specified in FR Y-14M technical specifications (e.g., CURR_BAL, CREDIT_LIMIT, INT_RATE, etc.)

COMPREHENSIVE DATA PROFILING RULES GENERATION:
Generate executable validation rules that can be directly implemented in SQL, Python, or similar validation frameworks. Each rule should:
- Use exact FR Y-14M attribute names
- Include specific validation logic that handles edge cases
- Test extreme values as part of the rule condition
- Account for common data quality issues

PROFILING RULE STRUCTURE:
Return a comprehensive JSON array with executable rules following this format:
[
  {
    "attribute_id": "EXACT_FR_Y14M_ATTRIBUTE_NAME",
    "rule_name": "Descriptive rule name",
    "rule_type": "completeness|format|range|relationship|business_logic|regulatory",
    "rule_category": "mandatory|conditional",
    "regulatory_requirement": "FR Y-14M Section X.X reference",
    "rule_logic": "EXECUTABLE VALIDATION LOGIC (SQL-like or Python-like pseudocode)",
    "expected_result": "PASS when [specific condition is true]",
    "severity": "critical|high|medium|low",
    "business_impact": "Specific impact description",
    "frequency": "daily|cycle_date|monthly"
  }
]

EXAMPLE EXECUTABLE RULES:

1. Credit Limit Validation with Edge Cases:
{
  "attribute_id": "CREDIT_LIMIT",
  "rule_name": "Credit Limit Range and Edge Case Validation",
  "rule_type": "range",
  "rule_category": "mandatory",
  "regulatory_requirement": "FR Y-14M Schedule D.1 Field 15",
  "rule_logic": "CREDIT_LIMIT >= 0 AND CREDIT_LIMIT <= 9999999 AND (CREDIT_LIMIT = 0 IMPLIES ACCOUNT_STATUS IN ('CLOSED', 'CHARGEOFF')) AND NOT (CREDIT_LIMIT > 0 AND CREDIT_LIMIT < 100 AND PRODUCT_TYPE != 'SECURED')",
  "expected_result": "PASS when credit limit is non-negative, within reporting range, and zero-limit accounts are properly closed",
  "severity": "critical",
  "business_impact": "Invalid credit limits affect utilization calculations and stress testing",
  "frequency": "daily"
}

2. Current Balance with Negative Balance Handling:
{
  "attribute_id": "CURR_BAL",
  "rule_name": "Current Balance Validation Including Credits",
  "rule_type": "business_logic",
  "rule_category": "mandatory",
  "regulatory_requirement": "FR Y-14M Schedule D.1 Field 18",
  "rule_logic": "CURR_BAL >= -999999 AND CURR_BAL <= 9999999 AND (CURR_BAL < 0 IMPLIES (CREDIT_ADJ > ABS(CURR_BAL) OR PAYMENT_AMT > PREV_BAL)) AND (CURR_BAL > CREDIT_LIMIT * 1.5 IMPLIES OVERLIMIT_FLAG = 'Y')",
  "expected_result": "PASS when balance is within range, negative balances have valid credits/overpayments, and overlimit scenarios are flagged",
  "severity": "critical",
  "business_impact": "Balance errors cascade to all risk calculations",
  "frequency": "daily"
}

3. APR Validation with Promotional Rate Logic:
{
  "attribute_id": "INT_RATE",
  "rule_name": "Interest Rate Range with Promotional APR Detection",
  "rule_type": "range",
  "rule_category": "mandatory",
  "regulatory_requirement": "FR Y-14M Schedule D.1 Field 25",
  "rule_logic": "(INT_RATE >= 0 AND INT_RATE <= 79.9) AND (INT_RATE = 0 IMPLIES (PROMO_RATE_FLAG = 'Y' OR PRODUCT_TYPE = 'EMPLOYEE' OR ACCOUNT_STATUS = 'CHARGEOFF')) AND (INT_RATE > 36 IMPLIES HIGH_APR_REASON IS NOT NULL)",
  "expected_result": "PASS when rate is within legal limits and zero rates are explained",
  "severity": "high",
  "business_impact": "Interest rates directly impact revenue projections and CARD Act compliance",
  "frequency": "monthly"
}

4. Utilization Rate Calculation with Edge Cases:
{
  "attribute_id": "UTIL_RATE",
  "rule_name": "Utilization Rate Logic with Zero Limit Handling",
  "rule_type": "business_logic",
  "rule_category": "mandatory",
  "regulatory_requirement": "FR Y-14M Schedule D.1 Derived Field",
  "rule_logic": "(CREDIT_LIMIT > 0 IMPLIES UTIL_RATE = ROUND(CURR_BAL / CREDIT_LIMIT * 100, 2)) AND (CREDIT_LIMIT = 0 IMPLIES UTIL_RATE = 999.99) AND (CURR_BAL < 0 IMPLIES UTIL_RATE = 0) AND UTIL_RATE >= 0 AND UTIL_RATE <= 999.99",
  "expected_result": "PASS when utilization correctly handles zero limits, negative balances, and overlimit",
  "severity": "high",
  "business_impact": "Utilization is key risk segmentation variable",
  "frequency": "daily"
}

5. Days Past Due with Roll Rate Validation:
{
  "attribute_id": "DAYS_PAST_DUE",
  "rule_name": "Days Past Due Progression Logic",
  "rule_type": "business_logic",
  "rule_category": "mandatory",
  "regulatory_requirement": "FR Y-14M Schedule D.1 Field 30",
  "rule_logic": "DAYS_PAST_DUE >= 0 AND DAYS_PAST_DUE <= 9999 AND (DAYS_PAST_DUE > 0 IMPLIES MIN_PAY_DUE > 0) AND (DAYS_PAST_DUE >= 180 IMPLIES ACCOUNT_STATUS = 'CHARGEOFF') AND (PREV_DPD > 0 AND PAYMENT_AMT >= MIN_PAY_DUE IMPLIES DAYS_PAST_DUE < PREV_DPD)",
  "expected_result": "PASS when DPD follows logical progression and aligns with payment behavior",
  "severity": "critical",
  "business_impact": "Delinquency drives loss forecasting and reserve calculations",
  "frequency": "daily"
}

6. Minimum Payment Calculation Validation:
{
  "attribute_id": "MIN_PAY_DUE",
  "rule_name": "Minimum Payment CARD Act Compliance",
  "rule_type": "regulatory",
  "rule_category": "mandatory",
  "regulatory_requirement": "FR Y-14M Schedule D.1 Field 35 / CARD Act",
  "rule_logic": "MIN_PAY_DUE >= 0 AND (CURR_BAL > 0 IMPLIES MIN_PAY_DUE >= GREATEST(25, CURR_BAL * 0.01 + FEE_BILLED + INT_CHARGED)) AND (CURR_BAL <= 25 AND CURR_BAL > 0 IMPLIES MIN_PAY_DUE = CURR_BAL) AND (DAYS_PAST_DUE > 0 IMPLIES MIN_PAY_DUE >= PAST_DUE_AMT)",
  "expected_result": "PASS when minimum payment meets CARD Act requirements",
  "severity": "critical",
  "business_impact": "CARD Act compliance violation risk",
  "frequency": "cycle_date"
}

7. Payment Allocation Validation:
{
  "attribute_id": "PAYMENT_AMT",
  "rule_name": "Payment Amount Range and Allocation Check",
  "rule_type": "business_logic",
  "rule_category": "mandatory",
  "regulatory_requirement": "FR Y-14M Schedule D.1 Field 40",
  "rule_logic": "PAYMENT_AMT >= 0 AND PAYMENT_AMT <= 999999 AND (PAYMENT_AMT > CURR_BAL + 10000 IMPLIES PAYMENT_REVERSAL_FLAG = 'Y') AND (PAYMENT_AMT > 0 AND PAYMENT_DATE IS NULL IMPLIES DATA_QUALITY_FLAG = 'ERROR')",
  "expected_result": "PASS when payment amounts are reasonable and have corresponding dates",
  "severity": "high",
  "business_impact": "Payment behavior drives revenue and loss models",
  "frequency": "daily"
}

8. Account Age Validation:
{
  "attribute_id": "ORIG_DATE",
  "rule_name": "Origination Date Logic with Vintage Validation",
  "rule_type": "temporal",
  "rule_category": "mandatory",
  "regulatory_requirement": "FR Y-14M Schedule D.1 Field 8",
  "rule_logic": "ORIG_DATE >= '19700101' AND ORIG_DATE <= REPORT_DATE AND MONTHS_BETWEEN(REPORT_DATE, ORIG_DATE) >= 0 AND MONTHS_BETWEEN(REPORT_DATE, ORIG_DATE) <= 600 AND (MONTHS_BETWEEN(REPORT_DATE, ORIG_DATE) > 360 IMPLIES LONG_TENURE_FLAG = 'Y')",
  "expected_result": "PASS when origination date is logical and account age is reasonable",
  "severity": "medium",
  "business_impact": "Vintage analysis accuracy for loss forecasting",
  "frequency": "monthly"
}

9. Cross-Field Balance Reconciliation:
{
  "attribute_id": "CURR_BAL",
  "rule_name": "Balance Component Reconciliation",
  "rule_type": "relationship",
  "rule_category": "mandatory",
  "regulatory_requirement": "FR Y-14M Schedule D.1 Balance Fields",
  "rule_logic": "ABS(CURR_BAL - (PRIN_BAL + INT_CHARGED + FEE_BILLED + OTHER_CHARGES)) <= 0.01 AND (CASH_ADV_BAL > 0 IMPLIES CASH_ADV_BAL <= CURR_BAL) AND (PROMO_BAL > 0 IMPLIES PROMO_BAL <= CURR_BAL)",
  "expected_result": "PASS when current balance equals sum of components within penny tolerance",
  "severity": "critical",
  "business_impact": "Balance integrity affects all downstream calculations",
  "frequency": "daily"
}

10. Charge-off Validation with Recovery:
{
  "attribute_id": "CHARGEOFF_AMT",
  "rule_name": "Charge-off Amount and Recovery Logic",
  "rule_type": "business_logic",
  "rule_category": "conditional",
  "regulatory_requirement": "FR Y-14M Schedule D.1 Field 45",
  "rule_logic": "(ACCOUNT_STATUS = 'CHARGEOFF' IMPLIES CHARGEOFF_AMT > 0) AND (CHARGEOFF_AMT > 0 IMPLIES DAYS_PAST_DUE >= 180) AND (RECOVERY_AMT > 0 IMPLIES CHARGEOFF_AMT > 0) AND (RECOVERY_AMT <= CHARGEOFF_AMT) AND (NET_CHARGEOFF = CHARGEOFF_AMT - RECOVERY_AMT)",
  "expected_result": "PASS when charge-off follows regulatory timing and recovery logic is consistent",
  "severity": "high",
  "business_impact": "Direct impact on loss rates and capital calculations",
  "frequency": "monthly"
}

KEY REQUIREMENTS FOR RULE GENERATION:
1. Use EXACT attribute names from FR Y-14M specifications
2. Include edge case handling within the rule logic (not as separate fields)
3. Test extreme values as part of the validation conditions
4. Make rules executable - they should translate directly to SQL WHERE clauses or Python conditions
5. Include NULL handling where appropriate (IS NULL, IS NOT NULL, COALESCE)
6. Use appropriate operators (=, !=, <, >, <=, >=, IN, NOT IN, BETWEEN, LIKE)
7. Include multi-condition logic using AND, OR, NOT operators
8. Reference specific regulatory requirements where applicable
9. Ensure mathematical calculations handle division by zero
10. Include tolerance thresholds for floating-point comparisons

⚠️ CRITICAL PANDAS CODE PATTERNS TO AVOID:
- NEVER use `df[df[condition]].apply(lambda x: complex_logic)` - this passes entire rows to lambda, not values
- NEVER use complex nested type conversions without error handling like `len(str(float(x)).split('.')[-1])`
- ALWAYS check column existence before referencing: `if 'other_column' not in df.columns: return {...}`
- ALWAYS use explicit iteration with try/except for complex value-by-value processing
- ALWAYS use exact database column names (lowercase with underscores)

Generate comprehensive profiling rules that:
- Are directly executable in validation systems
- Cover all edge cases and extreme values within the rule logic
- Use exact FR Y-14M attribute naming conventions
- Include clear pass/fail conditions
- Address common data quality issues proactively