"""
Authentication API endpoints
"""

from datetime import timedelta
from typing import Any
from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import HTTPAuthorizationCredentials
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

from app.core.database import get_db
from app.core.auth import (
    authenticate_user, 
    create_access_token, 
    get_password_hash,
    verify_password,
    UserRoles
)
from app.core.dependencies import get_current_user, require_management
from app.core.exceptions import AuthenticationException, ValidationException
from app.core.logging import audit_logger
from app.models.user import User
from app.models.lob import LOB
from app.schemas.auth import (
    LoginRequest, 
    TokenResponse, 
    TokenUser,
    PasswordChangeRequest,
    UserRegistrationRequest,
    AuthResponse
)
from app.schemas.user import UserResponse

router = APIRouter()


@router.post("/login", response_model=TokenResponse)
async def login(
    login_data: LoginRequest,
    db: AsyncSession = Depends(get_db)
) -> TokenResponse:
    """
    Authenticate user and return access token
    """
    # Authenticate user
    user = await authenticate_user(db, login_data.email, login_data.password)
    if not user:
        audit_logger.log_user_action(
            user_id=0,  # Unknown user
            action="login_failed",
            resource_type="auth",
            details={"email": login_data.email, "reason": "invalid_credentials"}
        )
        raise AuthenticationException("Invalid email or password")
    
    # Create access token
    access_token_expires = timedelta(minutes=30)  # From settings
    access_token = create_access_token(
        data={"sub": str(user.user_id), "email": user.email, "role": user.role},
        expires_delta=access_token_expires
    )
    
    # Log successful login
    audit_logger.log_user_action(
        user_id=user.user_id,
        action="login_success",
        resource_type="auth",
        details={"email": user.email, "role": user.role}
    )
    
    return TokenResponse(
        access_token=access_token,
        token_type="bearer",
        expires_in=int(access_token_expires.total_seconds()),
        user=TokenUser(
            user_id=user.user_id,
            email=user.email,
            first_name=user.first_name,
            last_name=user.last_name,
            role=user.role,
            lob_id=user.lob_id
        )
    )


@router.post("/register", response_model=UserResponse)
async def register_user(
    registration_data: UserRegistrationRequest,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(require_management)
) -> UserResponse:
    """
    Register a new user (management roles only)
    """
    # Check if email already exists
    existing_user = await db.execute(
        select(User).where(User.email == registration_data.email)
    )
    if existing_user.scalar_one_or_none():
        raise ValidationException("Email already registered")
    
    # Validate LOB exists if provided
    if registration_data.lob_id:
        lob_result = await db.execute(
            select(LOB).where(LOB.lob_id == registration_data.lob_id)
        )
        if not lob_result.scalar_one_or_none():
            raise ValidationException("Invalid LOB ID")
    
    # Validate role-LOB requirements
    if registration_data.role in [UserRoles.TESTER, UserRoles.DATA_OWNER, UserRoles.DATA_EXECUTIVE]:
        if not registration_data.lob_id:
            raise ValidationException(f"LOB ID is required for role: {registration_data.role}")
    
    # Create new user
    hashed_password = get_password_hash(registration_data.password)
    
    # Get next user_id
    max_user_result = await db.execute(select(User.user_id).order_by(User.user_id.desc()).limit(1))
    max_user_id = max_user_result.scalar_one_or_none()
    next_user_id = (max_user_id or 0) + 1
    
    new_user = User(
        user_id=next_user_id,
        first_name=registration_data.first_name,
        last_name=registration_data.last_name,
        email=registration_data.email,
        phone=registration_data.phone,
        role=registration_data.role,
        lob_id=registration_data.lob_id,
        is_active=True,
        hashed_password=hashed_password
    )
    
    db.add(new_user)
    await db.commit()
    await db.refresh(new_user)
    
    # Log user creation
    audit_logger.log_user_action(
        user_id=current_user.user_id,
        action="user_created",
        resource_type="user",
        resource_id=new_user.user_id,
        details={
            "created_user_email": new_user.email,
            "created_user_role": new_user.role,
            "created_user_lob_id": new_user.lob_id
        }
    )
    
    return UserResponse.model_validate(new_user)


@router.post("/change-password", response_model=AuthResponse)
async def change_password(
    password_data: PasswordChangeRequest,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
) -> AuthResponse:
    """
    Change user password
    """
    # Verify current password
    if not verify_password(password_data.current_password, current_user.hashed_password):
        raise AuthenticationException("Current password is incorrect")
    
    # Update password
    current_user.hashed_password = get_password_hash(password_data.new_password)
    await db.commit()
    
    # Log password change
    audit_logger.log_user_action(
        user_id=current_user.user_id,
        action="password_changed",
        resource_type="auth",
        details={"user_email": current_user.email}
    )
    
    return AuthResponse(
        success=True,
        message="Password changed successfully"
    )


@router.get("/me", response_model=UserResponse)
async def get_current_user_info(
    current_user: User = Depends(get_current_user)
) -> UserResponse:
    """
    Get current user information
    """
    return UserResponse.model_validate(current_user)


@router.post("/logout", response_model=AuthResponse)
async def logout(
    current_user: User = Depends(get_current_user)
) -> AuthResponse:
    """
    Logout user (token invalidation would be handled by client)
    """
    # Log logout
    audit_logger.log_user_action(
        user_id=current_user.user_id,
        action="logout",
        resource_type="auth",
        details={"user_email": current_user.email}
    )
    
    return AuthResponse(
        success=True,
        message="Logged out successfully"
    )


@router.get("/roles", response_model=dict)
async def get_available_roles() -> dict:
    """
    Get list of available user roles
    """
    return {
        "roles": UserRoles.all_roles(),
        "role_descriptions": {
            UserRoles.TESTER: "Execute testing workflow steps, manage attributes, conduct testing",
            UserRoles.TEST_EXECUTIVE: "Create test cycles, assign reports, monitor team progress",
            UserRoles.REPORT_OWNER: "Approve scoping, sampling, and observations",
            UserRoles.REPORT_OWNER_EXECUTIVE: "Portfolio oversight, executive reporting",
            UserRoles.DATA_OWNER: "Provide source documents, confirm data sources",
            UserRoles.DATA_EXECUTIVE: "Assign data providers, manage escalations"
        }
    } 