"""
Report management endpoints
"""

from typing import List, Optional
from fastapi import APIRouter, Depends, HTTPException, Query, status
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_, or_, func
from sqlalchemy.orm import selectinload
from datetime import datetime

from app.core.database import get_db
from app.core.dependencies import get_current_user, require_management
from app.core.auth import UserRoles, RoleChecker
from app.core.permissions import require_permission
from app.models.user import User
from app.models.lob import LOB
from app.models.report import Report
from app.schemas.report import (
    ReportCreate, ReportUpdate, ReportResponse, ReportListResponse,
    ReportSearchFilters, ReportStatsResponse, ReportOwnerAssignment,
    ReportLOBTransfer, ReportSummary, ReportTestingStart, ReportPhaseUpdate
)
from app.core.exceptions import ValidationException
from app.core.logging import get_logger
from app.crud import crud_report
from app.models.test_execution import TestExecutionPhase

logger = get_logger(__name__)
router = APIRouter()

# Role-based access control
management_roles = [UserRoles.TEST_EXECUTIVE, UserRoles.REPORT_OWNER, UserRoles.REPORT_OWNER_EXECUTIVE]
admin_roles = [UserRoles.TEST_EXECUTIVE]
owner_roles = [UserRoles.REPORT_OWNER, UserRoles.REPORT_OWNER_EXECUTIVE]


@router.post("/", response_model=ReportResponse, status_code=status.HTTP_201_CREATED)
@require_permission("reports", "create")
async def create_report(
    report_data: ReportCreate,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Create a new report
    """
    
    # Validate LOB exists
    lob_result = await db.execute(
        select(LOB).where(LOB.lob_id == report_data.lob_id)
    )
    if not lob_result.scalar_one_or_none():
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Invalid LOB ID"
        )
    
    # Validate report owner exists and has correct role
    if report_data.report_owner_id:
        owner_result = await db.execute(
            select(User).where(
                and_(
                    User.user_id == report_data.report_owner_id,
                    User.role.in_(owner_roles),
                    User.is_active == True
                )
            )
        )
        if not owner_result.scalar_one_or_none():
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid report owner ID or user is not a Report Owner"
            )
    
    # Check if report name already exists for this LOB
    existing_report = await db.execute(
        select(Report).where(
            and_(
                Report.report_name == report_data.report_name,
                Report.lob_id == report_data.lob_id
            )
        )
    )
    if existing_report.scalar_one_or_none():
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Report name already exists for this LOB"
        )
    
    # Create report
    db_report = Report(
        report_name=report_data.report_name,
        regulation=report_data.regulation,
        report_owner_id=report_data.report_owner_id,
        lob_id=report_data.lob_id,
        description=report_data.description,
        frequency=report_data.frequency,
        is_active=report_data.is_active
    )
    
    db.add(db_report)
    await db.commit()
    await db.refresh(db_report)
    
    logger.info(f"Report created: {db_report.report_name} for LOB {db_report.lob_id}")
    
    return ReportResponse.model_validate(db_report)


@router.get("/", response_model=ReportListResponse)
@require_permission("reports", "read")
async def list_reports(
    skip: int = Query(0, ge=0, description="Number of records to skip"),
    limit: int = Query(100, ge=1, le=1000, description="Number of records to return"),
    lob_id: Optional[int] = Query(None, description="Filter by LOB ID"),
    report_owner_id: Optional[int] = Query(None, description="Filter by report owner"),
    regulation: Optional[str] = Query(None, description="Filter by regulation"),
    is_active: Optional[bool] = Query(None, description="Filter by active status"),
    search: Optional[str] = Query(None, description="Search in report name or regulation"),
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    List reports with filtering and pagination
    """
    
    # Build query with relationships
    query = select(Report).options(
        selectinload(Report.lob),
        selectinload(Report.owner)
    )
    
    # Apply filters
    conditions = []
    
    # Role-based filtering
    if current_user.role == UserRoles.REPORT_OWNER:
        # Report owners can only see their own reports
        conditions.append(Report.report_owner_id == current_user.user_id)
    elif current_user.role == UserRoles.REPORT_OWNER_EXECUTIVE:
        # Executives can see reports from their report owners
        # TODO: Implement report owner hierarchy
        pass
    
    if lob_id is not None:
        conditions.append(Report.lob_id == lob_id)
    
    if report_owner_id is not None:
        conditions.append(Report.report_owner_id == report_owner_id)
    
    if regulation:
        conditions.append(Report.regulation.ilike(f"%{regulation}%"))
    
    if is_active is not None:
        conditions.append(Report.is_active == is_active)
    
    if search:
        search_term = f"%{search}%"
        conditions.append(
            or_(
                Report.report_name.ilike(search_term),
                Report.regulation.ilike(search_term),
                Report.description.ilike(search_term)
            )
        )
    
    if conditions:
        query = query.where(and_(*conditions))
    
    # Get total count
    count_query = select(func.count(Report.report_id))
    if conditions:
        count_query = count_query.where(and_(*conditions))
    
    total_result = await db.execute(count_query)
    total = total_result.scalar()
    
    # Apply pagination and execute
    query = query.offset(skip).limit(limit).order_by(Report.created_at.desc())
    result = await db.execute(query)
    reports = result.scalars().all()
    
    # Manually create response objects with populated relationship data
    report_responses = []
    for report in reports:
        report_data = {
            "report_id": report.report_id,
            "report_name": report.report_name,
            "regulation": report.regulation,
            "description": report.description,
            "frequency": report.frequency,
            "lob_id": report.lob_id,
            "report_owner_id": report.report_owner_id,
            "is_active": report.is_active,
            "created_at": report.created_at,
            "updated_at": report.updated_at,
            "lob_name": report.lob.lob_name if report.lob else None,
            "owner_name": f"{report.owner.first_name} {report.owner.last_name}" if report.owner else None
        }
        report_responses.append(ReportResponse(**report_data))
    
    return ReportListResponse(
        reports=report_responses,
        total=total,
        skip=skip,
        limit=limit
    )


@router.get("/{report_id}", response_model=ReportResponse)
@require_permission("reports", "read")
async def get_report(
    report_id: int,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Get report by ID
    """
    
    result = await db.execute(
        select(Report).options(
            selectinload(Report.lob),
            selectinload(Report.owner)
        ).where(Report.report_id == report_id)
    )
    report = result.scalar_one_or_none()
    
    if not report:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Report not found"
        )
    
    # Role-based access control
    if current_user.role == UserRoles.REPORT_OWNER:
        if report.report_owner_id != current_user.user_id:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Access denied: You can only view your own reports"
            )
    
    # Create response with populated relationship data
    report_data = {
        "report_id": report.report_id,
        "report_name": report.report_name,
        "regulation": report.regulation,
        "description": report.description,
        "frequency": report.frequency,
        "lob_id": report.lob_id,
        "report_owner_id": report.report_owner_id,
        "is_active": report.is_active,
        "created_at": report.created_at,
        "updated_at": report.updated_at,
        "lob_name": report.lob.lob_name if report.lob else None,
        "owner_name": f"{report.owner.first_name} {report.owner.last_name}" if report.owner else None
    }
    
    return ReportResponse(**report_data)


@router.put("/{report_id}", response_model=ReportResponse)
@require_permission("reports", "update")
async def update_report(
    report_id: int,
    report_data: ReportUpdate,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Update report information
    """
    
    # Get report
    result = await db.execute(
        select(Report).where(Report.report_id == report_id)
    )
    report = result.scalar_one_or_none()
    
    if not report:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Report not found"
        )
    
    # Validate LOB exists if being changed
    if report_data.lob_id and report_data.lob_id != report.lob_id:
        lob_result = await db.execute(
            select(LOB).where(LOB.lob_id == report_data.lob_id)
        )
        if not lob_result.scalar_one_or_none():
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid LOB ID"
            )
    
    # Validate report owner if being changed
    if report_data.report_owner_id and report_data.report_owner_id != report.report_owner_id:
        owner_result = await db.execute(
            select(User).where(
                and_(
                    User.user_id == report_data.report_owner_id,
                    User.role.in_(owner_roles),
                    User.is_active == True
                )
            )
        )
        if not owner_result.scalar_one_or_none():
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid report owner ID or user is not a Report Owner"
            )
    
    # Check name uniqueness if being changed
    if report_data.report_name and report_data.report_name != report.report_name:
        existing_report = await db.execute(
            select(Report).where(
                and_(
                    Report.report_name == report_data.report_name,
                    Report.lob_id == (report_data.lob_id or report.lob_id),
                    Report.report_id != report_id
                )
            )
        )
        if existing_report.scalar_one_or_none():
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Report name already exists for this LOB"
            )
    
    # Update fields
    update_data = report_data.model_dump(exclude_unset=True)
    for field, value in update_data.items():
        setattr(report, field, value)
    
    await db.commit()
    await db.refresh(report)
    
    logger.info(f"Report updated: {report.report_name}")
    
    return ReportResponse.model_validate(report)


@router.patch("/{report_id}/status")
@require_permission("reports", "update")
async def toggle_report_status(
    report_id: int,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Toggle report active status (Test Manager only)
    """
    
    # Get report
    result = await db.execute(
        select(Report).where(Report.report_id == report_id)
    )
    report = result.scalar_one_or_none()
    
    if not report:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Report not found"
        )
    
    # Toggle status
    report.is_active = not report.is_active
    await db.commit()
    
    status_text = "activated" if report.is_active else "deactivated"
    logger.info(f"Report {status_text}: {report.report_name}")
    
    return {"message": f"Report {status_text} successfully"}


@router.delete("/{report_id}")
@require_permission("reports", "delete")
async def delete_report(
    report_id: int,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Delete report (Test Manager only)
    """
    
    # Get report
    result = await db.execute(
        select(Report).where(Report.report_id == report_id)
    )
    report = result.scalar_one_or_none()
    
    if not report:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Report not found"
        )
    
    # Soft delete by deactivating
    report.is_active = False
    await db.commit()
    
    logger.info(f"Report deleted (deactivated): {report.report_name}")
    
    return {"message": "Report deleted successfully"}


@router.get("/stats/overview")
@require_permission("reports", "read")
async def get_report_stats(
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Get report statistics overview (Management only)
    """
    
    # Get report counts by LOB
    lob_counts = await db.execute(
        select(LOB.lob_name, func.count(Report.report_id))
        .select_from(Report)
        .join(LOB, Report.lob_id == LOB.lob_id)
        .where(Report.is_active == True)
        .group_by(LOB.lob_name)
    )
    
    reports_by_lob = {lob_name: count for lob_name, count in lob_counts.all()}
    
    # Get report counts by regulation
    regulation_counts = await db.execute(
        select(Report.regulation, func.count(Report.report_id))
        .where(Report.is_active == True)
        .group_by(Report.regulation)
    )
    
    reports_by_regulation = {regulation or "Unspecified": count for regulation, count in regulation_counts.all()}
    
    # Get report counts by owner
    owner_counts = await db.execute(
        select(
            func.concat(User.first_name, ' ', User.last_name).label('owner_name'),
            func.count(Report.report_id)
        )
        .select_from(Report)
        .join(User, Report.report_owner_id == User.user_id, isouter=True)
        .where(Report.is_active == True)
        .group_by(User.first_name, User.last_name)
    )
    
    reports_by_owner = {owner_name or "Unassigned": count for owner_name, count in owner_counts.all()}
    
    # Get total counts
    total_active = await db.execute(
        select(func.count(Report.report_id)).where(Report.is_active == True)
    )
    total_inactive = await db.execute(
        select(func.count(Report.report_id)).where(Report.is_active == False)
    )
    
    return {
        "total_active_reports": total_active.scalar(),
        "total_inactive_reports": total_inactive.scalar(),
        "reports_by_lob": reports_by_lob,
        "reports_by_regulation": reports_by_regulation,
        "reports_by_owner": reports_by_owner
    }


@router.get("/by-lob/{lob_id}")
@require_permission("reports", "read")
async def get_reports_by_lob(
    lob_id: int,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Get all reports for a specific LOB
    """
    
    # Validate LOB exists
    lob_result = await db.execute(
        select(LOB).where(LOB.lob_id == lob_id)
    )
    if not lob_result.scalar_one_or_none():
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="LOB not found"
        )
    
    # Get reports
    result = await db.execute(
        select(Report).options(
            selectinload(Report.lob),
            selectinload(Report.owner)
        ).where(
            and_(
                Report.lob_id == lob_id,
                Report.is_active == True
            )
        ).order_by(Report.report_name)
    )
    reports = result.scalars().all()
    
    return {
        "lob_id": lob_id,
        "reports": [ReportResponse.model_validate(report) for report in reports],
        "total": len(reports)
    }


@router.post("/{report_id}/start-testing", response_model=ReportResponse)
@require_permission("testing", "execute")
async def start_testing(
    report_id: int,
    testing_data: ReportTestingStart,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Start testing for a report in a cycle
    """
    
    # Create testing execution phase
    phase = TestExecutionPhase(
        report_id=report_id,
        cycle_id=testing_data.cycle_id,
        planned_start_date=testing_data.planned_start_date,
        planned_end_date=testing_data.planned_end_date,
        testing_deadline=testing_data.testing_deadline,
        test_strategy=testing_data.test_strategy,
        instructions=testing_data.instructions,
        phase_status="In Progress",
        started_at=datetime.utcnow(),
        started_by=current_user.user_id
    )
    db.add(phase)
    
    await db.commit()
    
    # Get the report for response
    result = await db.execute(
        select(Report)
        .options(
            selectinload(Report.lob),
            selectinload(Report.owner)
        )
        .where(Report.report_id == report_id)
    )
    report = result.scalar_one_or_none()
    
    return ReportResponse.model_validate(report)


@router.put("/phases/{phase_id}", response_model=ReportResponse)
@require_permission("testing", "update")
def update_phase_dates(
    phase_id: str,
    phase_data: ReportPhaseUpdate,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Update phase dates and details
    """
    
    phase = crud_report.get_testing_phase(db, phase_id)
    if not phase:
        raise HTTPException(
            status_code=404,
            detail="Phase not found"
        )
    
    # Update phase details
    phase = crud_report.update_testing_phase(
        db=db,
        phase_id=phase_id,
        planned_start_date=phase_data.planned_start_date,
        planned_end_date=phase_data.planned_end_date,
        testing_deadline=phase_data.testing_deadline,
        test_strategy=phase_data.test_strategy,
        instructions=phase_data.instructions
    )
    
    return phase.report 