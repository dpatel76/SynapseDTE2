"""
User management endpoints
"""

from typing import List, Optional, Union
from datetime import timedelta
from fastapi import APIRouter, Depends, HTTPException, Query, status
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_, or_, func
from sqlalchemy.orm import selectinload

from app.core.database import get_db
from app.core.dependencies import get_current_user, require_management
from app.core.auth import UserRoles, RoleChecker, get_password_hash, validate_password_strength, create_access_token
from app.core.permissions import require_permission
from app.models.user import User
from app.models.lob import LOB
from app.schemas.user import (
    UserCreate, UserUpdate, UserResponse, UserListResponse,
    UserSearchFilters, UserRoleUpdate
)
from app.core.exceptions import ValidationException
from app.core.logging import get_logger

logger = get_logger(__name__)
router = APIRouter()

# Role-based access control
management_roles = [UserRoles.TEST_EXECUTIVE, UserRoles.REPORT_OWNER_EXECUTIVE, UserRoles.DATA_EXECUTIVE]
admin_roles = [UserRoles.TEST_EXECUTIVE]


@router.post("/", response_model=UserResponse, status_code=status.HTTP_201_CREATED)
@require_permission("users", "create")
async def create_user(
    user_data: UserCreate,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Create a new user (Test Manager only)
    """
    
    # Validate password strength
    if not validate_password_strength(user_data.password):
        raise ValidationException("Password does not meet security requirements")
    
    # Check if email already exists
    existing_user = await db.execute(
        select(User).where(User.email == user_data.email)
    )
    if existing_user.scalar_one_or_none():
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Email already registered"
        )
    
    # Validate LOB exists if provided
    if user_data.lob_id:
        lob_result = await db.execute(
            select(LOB).where(LOB.lob_id == user_data.lob_id)
        )
        if not lob_result.scalar_one_or_none():
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid LOB ID"
            )
    
    # Create user
    hashed_password = get_password_hash(user_data.password)
    db_user = User(
        first_name=user_data.first_name,
        last_name=user_data.last_name,
        email=user_data.email,
        phone=user_data.phone,
        role=user_data.role,
        lob_id=user_data.lob_id,
        hashed_password=hashed_password,
        is_active=user_data.is_active
    )
    
    db.add(db_user)
    await db.commit()
    await db.refresh(db_user)
    
    logger.info(f"User created: {db_user.email} with role {db_user.role}")
    
    return UserResponse.model_validate(db_user)


@router.get("/")
@require_permission("users", "read")
async def list_users(
    skip: int = Query(0, ge=0, description="Number of records to skip"),
    limit: int = Query(100, ge=1, le=1000, description="Number of records to return"),
    role: Optional[str] = Query(None, description="Filter by role"),
    lob_id: Optional[int] = Query(None, description="Filter by LOB ID"),
    is_active: Optional[bool] = Query(None, description="Filter by active status"),
    search: Optional[str] = Query(None, description="Search in name or email"),
    include_roles: Optional[bool] = Query(False, description="Include RBAC roles for each user"),
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
) -> Union[UserListResponse, List[dict]]:
    """
    List users with filtering and pagination
    """
    
    # Build query
    query = select(User).options(selectinload(User.lob))
    
    # If RBAC roles are requested, include them
    if include_roles:
        from app.models.rbac import UserRole, Role
        query = query.options(
            selectinload(User.user_roles).selectinload(UserRole.role)
        )
    
    # Apply filters
    conditions = []
    
    if role:
        conditions.append(User.role == role)
    
    if lob_id is not None:
        conditions.append(User.lob_id == lob_id)
    
    if is_active is not None:
        conditions.append(User.is_active == is_active)
    
    if search:
        search_term = f"%{search}%"
        conditions.append(
            or_(
                User.first_name.ilike(search_term),
                User.last_name.ilike(search_term),
                User.email.ilike(search_term)
            )
        )
    
    if conditions:
        query = query.where(and_(*conditions))
    
    # Get total count
    count_query = select(func.count(User.user_id))
    if conditions:
        count_query = count_query.where(and_(*conditions))
    
    total_result = await db.execute(count_query)
    total = total_result.scalar()
    
    # Apply pagination and execute
    query = query.offset(skip).limit(limit).order_by(User.created_at.desc())
    result = await db.execute(query)
    users = result.scalars().all()
    
    # If RBAC roles are requested, format the response appropriately
    if include_roles:
        from datetime import datetime
        
        # Transform users to include RBAC role information
        users_with_roles = []
        for user in users:
            user_dict = {
                "user_id": user.user_id,
                "email": user.email,
                "full_name": f"{user.first_name} {user.last_name}",
                "first_name": user.first_name,
                "last_name": user.last_name,
                "role": user.role,  # Traditional role
                "is_active": user.is_active,
                "roles": []  # RBAC roles
            }
            
            # Add RBAC roles (only active and non-expired ones)
            if hasattr(user, 'user_roles'):
                for user_role in user.user_roles:
                    if (user_role.expires_at is None or user_role.expires_at > datetime.utcnow()):
                        user_dict["roles"].append({
                            "role_id": user_role.role.role_id,
                            "role_name": user_role.role.role_name,
                            "description": user_role.role.description,
                            "is_system": user_role.role.is_system,
                            "is_active": user_role.role.is_active
                        })
            
            users_with_roles.append(user_dict)
        
        # Return raw list for RBAC management (no validation)
        return users_with_roles
    
    # Standard response for normal user listing
    return UserListResponse(
        users=[UserResponse.model_validate(user) for user in users],
        total=total,
        skip=skip,
        limit=limit
    )


@router.get("/me", response_model=UserResponse)
async def get_current_user_info(
    current_user: User = Depends(get_current_user)
):
    """Get current user information"""
    return UserResponse.model_validate(current_user)


@router.get("/report-owners", response_model=List[UserResponse])
@require_permission("users", "read")
async def get_report_owners(
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Get all users who can be report owners (Report Owner and Report Owner Executive roles)
    """
    
    # Query for users with report owner roles
    result = await db.execute(
        select(User).options(selectinload(User.lob)).where(
            and_(
                User.role.in_([UserRoles.REPORT_OWNER, UserRoles.REPORT_OWNER_EXECUTIVE]),
                User.is_active == True
            )
        ).order_by(User.first_name, User.last_name)
    )
    users = result.scalars().all()
    
    return [UserResponse.model_validate(user) for user in users]


@router.get("/{user_id}", response_model=UserResponse)
@require_permission("users", "read")
async def get_user(
    user_id: int,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Get user by ID
    """
    # Additional check - users can view their own profile even without full read permission
    # The @require_permission decorator handles the general case
    
    result = await db.execute(
        select(User).options(selectinload(User.lob)).where(User.user_id == user_id)
    )
    user = result.scalar_one_or_none()
    
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    
    return UserResponse.model_validate(user)


@router.put("/{user_id}", response_model=UserResponse)
@require_permission("users", "update")
async def update_user(
    user_id: int,
    user_data: UserUpdate,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Update user information
    """
    # Additional logic handled below for self-updates
    
    # Get user
    result = await db.execute(
        select(User).where(User.user_id == user_id)
    )
    user = result.scalar_one_or_none()
    
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    
    # Check email uniqueness if email is being changed
    if user_data.email and user_data.email != user.email:
        existing_user = await db.execute(
            select(User).where(and_(User.email == user_data.email, User.user_id != user_id))
        )
        if existing_user.scalar_one_or_none():
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Email already registered"
            )
    
    # Validate LOB exists if provided
    if user_data.lob_id:
        lob_result = await db.execute(
            select(LOB).where(LOB.lob_id == user_data.lob_id)
        )
        if not lob_result.scalar_one_or_none():
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid LOB ID"
            )
    
    # Update fields
    update_data = user_data.model_dump(exclude_unset=True)
    
    # Non-admin users can only update limited fields
    if current_user.user_id == user_id and current_user.role not in admin_roles:
        allowed_fields = {'first_name', 'last_name', 'phone'}
        update_data = {k: v for k, v in update_data.items() if k in allowed_fields}
    
    for field, value in update_data.items():
        setattr(user, field, value)
    
    await db.commit()
    await db.refresh(user)
    
    logger.info(f"User updated: {user.email}")
    
    return UserResponse.model_validate(user)


@router.patch("/{user_id}/role", response_model=UserResponse)
@require_permission("users", "update")
async def update_user_role(
    user_id: int,
    role_data: UserRoleUpdate,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Update user role (Test Manager only)
    """
    
    # Get user
    result = await db.execute(
        select(User).where(User.user_id == user_id)
    )
    user = result.scalar_one_or_none()
    
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    
    # Update role
    user.role = role_data.role
    if role_data.lob_id is not None:
        user.lob_id = role_data.lob_id
    
    await db.commit()
    await db.refresh(user)
    
    logger.info(f"User role updated: {user.email} -> {user.role}")
    
    return UserResponse.model_validate(user)


@router.patch("/{user_id}/status")
@require_permission("users", "update")
async def toggle_user_status(
    user_id: int,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Toggle user active status (Test Manager only)
    """
    
    # Get user
    result = await db.execute(
        select(User).where(User.user_id == user_id)
    )
    user = result.scalar_one_or_none()
    
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    
    # Cannot deactivate self
    if user_id == current_user.user_id:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Cannot deactivate your own account"
        )
    
    # Toggle status
    user.is_active = not user.is_active
    await db.commit()
    
    status_text = "activated" if user.is_active else "deactivated"
    logger.info(f"User {status_text}: {user.email}")
    
    return {"message": f"User {status_text} successfully"}


@router.delete("/{user_id}")
@require_permission("users", "delete")
async def delete_user(
    user_id: int,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Delete user (Test Manager only)
    """
    
    # Get user
    result = await db.execute(
        select(User).where(User.user_id == user_id)
    )
    user = result.scalar_one_or_none()
    
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    
    # Cannot delete self
    if user_id == current_user.user_id:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Cannot delete your own account"
        )
    
    # Soft delete by deactivating
    user.is_active = False
    await db.commit()
    
    logger.info(f"User deleted (deactivated): {user.email}")
    
    return {"message": "User deleted successfully"}


@router.post("/{user_id}/impersonate")
async def impersonate_user(
    user_id: int,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Impersonate another user (Admin only)
    """
    # Check permissions - only Admin can impersonate
    if current_user.role != UserRoles.ADMIN:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Only Admin users can impersonate other users"
        )
    
    # Get target user
    result = await db.execute(
        select(User).options(selectinload(User.lob)).where(User.user_id == user_id)
    )
    target_user = result.scalar_one_or_none()
    
    if not target_user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    
    # Cannot impersonate self
    if user_id == current_user.user_id:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Cannot impersonate yourself"
        )
    
    # Cannot impersonate inactive users
    if not target_user.is_active:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Cannot impersonate inactive user"
        )
    
    # Create impersonation token
    access_token_expires = timedelta(minutes=30)
    access_token = create_access_token(
        data={
            "sub": str(target_user.user_id), 
            "email": target_user.email, 
            "role": target_user.role,
            "impersonated_by": current_user.user_id
        },
        expires_delta=access_token_expires
    )
    
    logger.info(f"User impersonation started: {current_user.email} -> {target_user.email}")
    
    return {
        "access_token": access_token,
        "token_type": "bearer",
        "impersonated_user": UserResponse.model_validate(target_user)
    }


@router.get("/roles/available")
async def get_available_roles(
    current_user: User = Depends(get_current_user)
):
    """
    Get list of available user roles
    """
    return {
        "roles": UserRoles.all_roles(),
        "role_descriptions": {
            UserRoles.ADMIN: "Full system access, user management, role simulation, and system configuration",
            UserRoles.TESTER: "Execute testing workflow steps, manage attributes, conduct testing",
            UserRoles.TEST_EXECUTIVE: "Create test cycles, assign reports, monitor team progress",
            UserRoles.REPORT_OWNER: "Approve scoping, sampling, and observations",
            UserRoles.REPORT_OWNER_EXECUTIVE: "Portfolio oversight, executive reporting",
            UserRoles.DATA_OWNER: "Provide source documents, confirm data sources",
            UserRoles.DATA_EXECUTIVE: "Assign data providers, manage escalations"
        }
    }


@router.get("/stats/overview")
@require_permission("users", "read")
async def get_user_stats(
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Get user statistics overview (Management only)
    """
    
    # Get counts by role
    role_counts = {}
    for role in UserRoles:
        count_result = await db.execute(
            select(func.count(User.user_id)).where(
                and_(User.role == role, User.is_active == True)
            )
        )
        role_counts[role.value] = count_result.scalar()
    
    # Get total active users
    total_result = await db.execute(
        select(func.count(User.user_id)).where(User.is_active == True)
    )
    total_active = total_result.scalar()
    
    # Get total inactive users
    inactive_result = await db.execute(
        select(func.count(User.user_id)).where(User.is_active == False)
    )
    total_inactive = inactive_result.scalar()
    
    return {
        "total_active_users": total_active,
        "total_inactive_users": total_inactive,
        "users_by_role": role_counts
    }


@router.get("/by-email/{email}", response_model=UserResponse)
@require_permission("users", "read")
async def get_user_by_email(
    email: str,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Get user by email
    """
    # Additional check - users can view their own profile even without full read permission
    # The @require_permission decorator handles the general case
    
    result = await db.execute(
        select(User).options(selectinload(User.lob)).where(User.email == email)
    )
    user = result.scalar_one_or_none()
    
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    
    return UserResponse.model_validate(user) 