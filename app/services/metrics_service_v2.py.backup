"""
Enhanced Metrics Service V2
Uses real data through role-specific metric calculators
"""

import logging
from typing import Dict, Any, List, Optional
from datetime import datetime, timedelta
from sqlalchemy import select, and_
from sqlalchemy.ext.asyncio import AsyncSession

from app.services.metrics import (
    TesterMetricsCalculator,
    TestExecutiveMetricsCalculator,
    ReportOwnerMetricsCalculator,
    DataProviderMetricsCalculator,
    DataExecutiveMetricsCalculator
)
from app.models.user import User
from app.models.lob_assignment import LOBAssignment
from app.models.regulatory_reports import ReportOwnerAssignment

logger = logging.getLogger(__name__)


class MetricsServiceV2:
    """Enhanced metrics service using real data from metric calculators"""
    
    def __init__(self):
        self._cache = {}
        self._cache_ttl = 300  # 5 minutes
    
    async def get_dashboard_metrics(
        self,
        user_id: str,
        db: AsyncSession,
        cycle_id: Optional[str] = None,
        time_period: str = "current_cycle"
    ) -> Dict[str, Any]:
        """Get dashboard metrics based on user role"""
        # Get user details
        user = await db.get(User, user_id)
        if not user:
            return {"error": "User not found"}
        
        # Route to appropriate calculator based on role
        if user.role == "Tester":
            return await self._get_tester_metrics(user_id, db, cycle_id, time_period)
        elif user.role == "Test Manager":
            return await self._get_test_executive_metrics(user_id, db, cycle_id, time_period)
        elif user.role == "Report Owner":
            return await self._get_report_owner_metrics(user_id, db, cycle_id, time_period)
        elif user.role == "Report Owner Executive":
            return await self._get_report_owner_metrics(user_id, db, cycle_id, time_period, is_executive=True)
        elif user.role == "Data Owner":
            return await self._get_data_provider_metrics(user_id, db, cycle_id, time_period)
        elif user.role == "CDO":
            return await self._get_data_executive_metrics(user_id, db, cycle_id, time_period)
        else:
            return {"error": f"Unknown role: {user.role}"}
    
    async def _get_tester_metrics(
        self,
        user_id: str,
        db: AsyncSession,
        cycle_id: Optional[str],
        time_period: str
    ) -> Dict[str, Any]:
        """Get metrics for Tester role"""
        calculator = TesterMetricsCalculator(db)
        
        try:
            metrics = await calculator.get_tester_dashboard_metrics(
                tester_id=user_id,
                cycle_id=cycle_id,
                time_period=time_period
            )
            
            # Add report testing summaries for assigned reports
            if metrics["report_metrics"]:
                for report_metric in metrics["report_metrics"]:
                    if report_metric.get("status") in ["in_progress", "completed"]:
                        testing_summary = await calculator.get_report_testing_summary(
                            tester_id=user_id,
                            cycle_id=report_metric["cycle_id"],
                            report_id=report_metric["report_id"]
                        )
                        report_metric["testing_summary"] = testing_summary
            
            return {
                "role": "Tester",
                "user_id": user_id,
                **metrics
            }
            
        except Exception as e:
            logger.error(f"Error generating tester metrics: {str(e)}")
            return {"error": "Failed to generate metrics", "details": str(e)}
    
    async def _get_test_executive_metrics(
        self,
        user_id: str,
        db: AsyncSession,
        cycle_id: Optional[str],
        time_period: str
    ) -> Dict[str, Any]:
        """Get metrics for Test Executive role"""
        calculator = TestExecutiveMetricsCalculator(db)
        
        try:
            metrics = await calculator.get_test_executive_dashboard_metrics(
                executive_id=user_id,
                cycle_id=cycle_id,
                time_period=time_period
            )
            
            # Add cycle comparisons if multiple cycles
            if len(metrics.get("cycle_metrics", [])) > 1:
                cycle_ids = [c["cycle_id"] for c in metrics["cycle_metrics"]]
                comparison = await calculator.get_cycle_comparison_metrics(
                    executive_id=user_id,
                    cycle_ids=cycle_ids[:3]  # Compare last 3 cycles
                )
                metrics["cycle_comparison"] = comparison
            
            return {
                "role": "Test Executive",
                "user_id": user_id,
                **metrics
            }
            
        except Exception as e:
            logger.error(f"Error generating test executive metrics: {str(e)}")
            return {"error": "Failed to generate metrics", "details": str(e)}
    
    async def _get_report_owner_metrics(
        self,
        user_id: str,
        db: AsyncSession,
        cycle_id: Optional[str],
        time_period: str,
        is_executive: bool = False
    ) -> Dict[str, Any]:
        """Get metrics for Report Owner or Report Owner Executive role"""
        calculator = ReportOwnerMetricsCalculator(db)
        
        try:
            metrics = await calculator.get_report_owner_dashboard_metrics(
                owner_id=user_id,
                is_executive=is_executive,
                cycle_id=cycle_id,
                time_period=time_period
            )
            
            # Add report comparisons if multiple reports
            if len(metrics.get("report_metrics", [])) > 1:
                report_ids = [r["report_id"] for r in metrics["report_metrics"]]
                comparison = await calculator.get_report_comparison_metrics(
                    owner_id=user_id,
                    report_ids=report_ids[:5],  # Compare up to 5 reports
                    cycle_id=cycle_id
                )
                metrics["report_comparison"] = comparison
            
            return {
                "role": "Report Owner Executive" if is_executive else "Report Owner",
                "user_id": user_id,
                **metrics
            }
            
        except Exception as e:
            logger.error(f"Error generating report owner metrics: {str(e)}")
            return {"error": "Failed to generate metrics", "details": str(e)}
    
    async def _get_data_provider_metrics(
        self,
        user_id: str,
        db: AsyncSession,
        cycle_id: Optional[str],
        time_period: str
    ) -> Dict[str, Any]:
        """Get metrics for Data Provider role"""
        calculator = DataProviderMetricsCalculator(db)
        
        try:
            metrics = await calculator.get_data_provider_dashboard_metrics(
                provider_id=user_id,
                cycle_id=cycle_id,
                time_period=time_period
            )
            
            # Add test case details for active assignments
            if metrics.get("assignment_metrics"):
                for assignment in metrics["assignment_metrics"]:
                    if assignment.get("completion_status", {}).get("in_progress", 0) > 0:
                        test_details = await calculator.get_provider_test_case_details(
                            provider_id=user_id,
                            cycle_id=assignment["cycle_id"],
                            report_id=assignment["report_id"]
                        )
                        assignment["test_details"] = test_details
            
            return {
                "role": "Data Provider",
                "user_id": user_id,
                **metrics
            }
            
        except Exception as e:
            logger.error(f"Error generating data provider metrics: {str(e)}")
            return {"error": "Failed to generate metrics", "details": str(e)}
    
    async def _get_data_executive_metrics(
        self,
        user_id: str,
        db: AsyncSession,
        cycle_id: Optional[str],
        time_period: str
    ) -> Dict[str, Any]:
        """Get metrics for Data Executive (CDO) role"""
        # First, get the LOB for this CDO
        lob_query = await db.execute(
            select(LOBAssignment.lob_name)
            .where(LOBAssignment.executive_id == user_id)
            .distinct()
        )
        lob_names = [row[0] for row in lob_query]
        
        if not lob_names:
            return {"error": "No LOB assignments found for this CDO"}
        
        # For now, use the first LOB (could be enhanced to support multiple)
        lob_name = lob_names[0]
        
        calculator = DataExecutiveMetricsCalculator(db)
        
        try:
            metrics = await calculator.get_data_executive_dashboard_metrics(
                executive_id=user_id,
                lob_name=lob_name,
                cycle_id=cycle_id,
                time_period=time_period
            )
            
            # Add provider comparison
            if cycle_id:
                provider_comparison = await calculator.get_provider_comparison_metrics(
                    lob_name=lob_name,
                    cycle_id=cycle_id
                )
                metrics["provider_comparison"] = provider_comparison
            
            # Add report breakdown
            report_breakdown = await calculator.get_lob_report_breakdown(
                lob_name=lob_name,
                cycle_id=cycle_id
            )
            metrics["report_breakdown"] = report_breakdown
            
            return {
                "role": "Data Executive (CDO)",
                "user_id": user_id,
                "lob_name": lob_name,
                **metrics
            }
            
        except Exception as e:
            logger.error(f"Error generating data executive metrics: {str(e)}")
            return {"error": "Failed to generate metrics", "details": str(e)}
    
    async def get_phase_metrics(
        self,
        cycle_id: str,
        report_id: str,
        phase_name: str,
        db: AsyncSession,
        lob_name: Optional[str] = None
    ) -> Dict[str, Any]:
        """Get detailed metrics for a specific phase"""
        from app.services.metrics import BaseMetricsCalculator
        
        calculator = BaseMetricsCalculator(db)
        
        try:
            metrics = await calculator.calculate_phase_metrics(
                cycle_id=cycle_id,
                report_id=report_id,
                phase_name=phase_name,
                lob_name=lob_name
            )
            
            # Add SLA compliance for this phase
            sla_compliance = await calculator.calculate_sla_compliance(
                cycle_id=cycle_id,
                report_id=report_id,
                phase_name=phase_name
            )
            metrics["sla_compliance"] = sla_compliance
            
            return metrics
            
        except Exception as e:
            logger.error(f"Error generating phase metrics: {str(e)}")
            return {"error": "Failed to generate phase metrics", "details": str(e)}
    
    async def get_aggregate_metrics(
        self,
        cycle_id: str,
        db: AsyncSession,
        report_id: Optional[str] = None,
        lob_name: Optional[str] = None
    ) -> Dict[str, Any]:
        """Get aggregate metrics for a cycle or report"""
        from app.services.metrics import BaseMetricsCalculator
        
        calculator = BaseMetricsCalculator(db)
        
        try:
            # Get aggregate report metrics
            aggregate = await calculator.aggregate_report_metrics(
                cycle_id=cycle_id,
                report_id=report_id,
                lob_name=lob_name
            )
            
            # Add error rates
            if report_id:
                sample_errors = await calculator.calculate_error_rates(
                    cycle_id=cycle_id,
                    report_id=report_id,
                    entity_type="sample"
                )
                attribute_errors = await calculator.calculate_error_rates(
                    cycle_id=cycle_id,
                    report_id=report_id,
                    entity_type="attribute"
                )
                test_case_errors = await calculator.calculate_error_rates(
                    cycle_id=cycle_id,
                    report_id=report_id,
                    entity_type="test_case"
                )
                
                aggregate["error_rates"] = {
                    "sample": sample_errors,
                    "attribute": attribute_errors,
                    "test_case": test_case_errors
                }
            
            # Add SLA compliance
            sla_compliance = await calculator.calculate_sla_compliance(
                cycle_id=cycle_id,
                report_id=report_id
            )
            aggregate["sla_compliance"] = sla_compliance
            
            return aggregate
            
        except Exception as e:
            logger.error(f"Error generating aggregate metrics: {str(e)}")
            return {"error": "Failed to generate aggregate metrics", "details": str(e)}
    
    async def refresh_phase_metrics(
        self,
        cycle_id: str,
        report_id: str,
        phase_name: str,
        db: AsyncSession
    ) -> bool:
        """Refresh phase metrics in the database"""
        from app.models.metrics import PhaseMetrics
        from app.services.metrics import BaseMetricsCalculator
        
        calculator = BaseMetricsCalculator(db)
        
        try:
            # Calculate current metrics
            metrics = await calculator.calculate_phase_metrics(
                cycle_id=cycle_id,
                report_id=report_id,
                phase_name=phase_name
            )
            
            # Check if record exists
            existing = await db.execute(
                select(PhaseMetrics).where(
                    and_(
                        PhaseMetrics.cycle_id == cycle_id,
                        PhaseMetrics.report_id == report_id,
                        PhaseMetrics.phase_name == phase_name
                    )
                )
            )
            phase_metric = existing.scalar_one_or_none()
            
            if not phase_metric:
                # Create new record
                phase_metric = PhaseMetrics(
                    cycle_id=cycle_id,
                    report_id=report_id,
                    phase_name=phase_name
                )
                db.add(phase_metric)
            
            # Update metrics
            for key, value in metrics.items():
                if hasattr(phase_metric, key):
                    setattr(phase_metric, key, value)
            
            await db.commit()
            return True
            
        except Exception as e:
            logger.error(f"Error refreshing phase metrics: {str(e)}")
            await db.rollback()
            return False


# Singleton instance
_metrics_service = None


def get_metrics_service() -> MetricsServiceV2:
    """Get singleton metrics service instance"""
    global _metrics_service
    if _metrics_service is None:
        _metrics_service = MetricsServiceV2()
    return _metrics_service