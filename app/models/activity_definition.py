"""
Activity Definition and State Tracking Models
Database-driven activity management system
"""

from sqlalchemy import Column, Integer, String, Boolean, ForeignKey, DateTime, JSON, UniqueConstraint, Index
from sqlalchemy.orm import relationship
from datetime import datetime

from app.models.base import CustomPKModel
from app.models.audit_mixin import AuditMixin


class ActivityDefinition(CustomPKModel, AuditMixin):
    """
    Defines activities available in each phase
    This is the master template for activities
    """
    __tablename__ = "activity_definitions"
    
    id = Column(Integer, primary_key=True)
    phase_name = Column(String(50), nullable=False)  # e.g., "Planning", "Scoping"
    activity_name = Column(String(100), nullable=False)  # e.g., "Start Planning Phase"
    activity_code = Column(String(50), nullable=False, unique=True)  # e.g., "start_planning"
    description = Column(String(500))
    
    # Activity type and behavior
    activity_type = Column(String(50), nullable=False)  # "phase_start", "phase_complete", "manual", "automated"
    requires_backend_action = Column(Boolean, default=False)  # Does this trigger a backend process?
    backend_endpoint = Column(String(200))  # Optional: specific endpoint to call
    
    # Sequencing and dependencies
    sequence_order = Column(Integer, nullable=False)  # Order within the phase
    depends_on_activity_codes = Column(JSON, default=list)  # List of activity codes this depends on
    
    # UI Configuration
    button_text = Column(String(50))  # e.g., "Start Phase", "Load Attributes"
    success_message = Column(String(200))  # Message to show on completion
    instructions = Column(String(500))  # Instructions for manual activities
    
    # Validation rules
    can_skip = Column(Boolean, default=False)
    can_reset = Column(Boolean, default=True)
    auto_complete_on_condition = Column(JSON)  # Optional: conditions for auto-completion
    conditional_skip_rules = Column(JSON)  # Optional: rules for conditional skipping
    
    # Status
    is_active = Column(Boolean, default=True)
    
    # Indexes
    __table_args__ = (
        UniqueConstraint('phase_name', 'activity_name', name='uq_phase_activity'),
        Index('idx_activity_phase_sequence', 'phase_name', 'sequence_order'),
        Index('idx_activity_code', 'activity_code'),
    )
    
    # Relationships
    activity_states = relationship("ActivityState", back_populates="activity_definition")
    
    def __repr__(self):
        return f"<ActivityDefinition(code={self.activity_code}, phase={self.phase_name}, name={self.activity_name})>"


class ActivityState(CustomPKModel, AuditMixin):
    """
    Tracks the actual state of activities for specific cycle/report combinations
    This is the instance data for each activity execution
    """
    __tablename__ = "activity_states"
    
    id = Column(Integer, primary_key=True)
    
    # Context
    cycle_id = Column(Integer, nullable=False)
    report_id = Column(Integer, nullable=False)
    phase_name = Column(String(50), nullable=False)
    
    # Link to definition
    activity_definition_id = Column(Integer, ForeignKey('activity_definitions.id'), nullable=False)
    
    # State tracking
    status = Column(String(20), nullable=False, default='pending')  # pending, active, completed, blocked, skipped
    started_at = Column(DateTime)
    started_by = Column(Integer, ForeignKey('users.user_id'))
    completed_at = Column(DateTime)
    completed_by = Column(Integer, ForeignKey('users.user_id'))
    
    # Blocking information
    is_blocked = Column(Boolean, default=False)
    blocking_reason = Column(String(500))
    blocked_by_activities = Column(JSON, default=list)  # List of activity IDs blocking this
    
    # Completion data
    completion_data = Column(JSON)  # Any data generated by the activity
    completion_notes = Column(String(1000))
    
    # Reset tracking
    reset_count = Column(Integer, default=0)
    last_reset_at = Column(DateTime)
    last_reset_by = Column(Integer, ForeignKey('users.user_id'))
    
    # Indexes
    __table_args__ = (
        UniqueConstraint('cycle_id', 'report_id', 'activity_definition_id', name='uq_activity_state'),
        Index('idx_activity_state_context', 'cycle_id', 'report_id', 'phase_name'),
        Index('idx_activity_state_status', 'status'),
    )
    
    # Relationships
    activity_definition = relationship("ActivityDefinition", back_populates="activity_states")
    started_by_user = relationship("User", foreign_keys=[started_by])
    completed_by_user = relationship("User", foreign_keys=[completed_by])
    last_reset_by_user = relationship("User", foreign_keys=[last_reset_by])
    
    def __repr__(self):
        return f"<ActivityState(cycle={self.cycle_id}, report={self.report_id}, activity={self.activity_definition_id}, status={self.status})>"
    
    @property
    def can_start(self) -> bool:
        """Check if this activity can be started based on dependencies"""
        return self.status == 'pending' and not self.is_blocked
    
    @property
    def can_complete(self) -> bool:
        """Check if this activity can be completed"""
        return self.status == 'active'
    
    @property
    def completion_percentage(self) -> int:
        """Calculate completion percentage"""
        if self.status == 'completed':
            return 100
        elif self.status == 'active':
            return 50
        else:
            return 0