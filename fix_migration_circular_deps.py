#!/usr/bin/env python3
"""
Fix circular dependency in Alembic migration by moving foreign keys to the end.
"""

import re


def fix_circular_dependencies(input_file: str, output_file: str):
    """Fix circular dependencies by extracting foreign keys and adding them at the end."""
    
    with open(input_file, 'r') as f:
        content = f.read()
    
    # Find the upgrade function
    upgrade_match = re.search(r'def upgrade\(\) -> None:(.*?)def downgrade\(\) -> None:', content, re.DOTALL)
    if not upgrade_match:
        print("ERROR: Could not find upgrade function")
        return False
        
    upgrade_content = upgrade_match.group(1)
    
    # Extract all table creations
    table_pattern = r'(op\.create_table\([^)]+\)(.*?)\n    \))'
    tables = re.findall(table_pattern, upgrade_content, re.DOTALL)
    
    # Process each table
    foreign_keys = []
    new_tables = []
    
    for table_match in tables:
        table_start = table_match[0]
        table_content = table_match[1]
        
        # Extract table name
        table_name_match = re.search(r"op\.create_table\('([^']+)'", table_start)
        if not table_name_match:
            continue
        table_name = table_name_match.group(1)
        
        # Find all ForeignKeyConstraint lines
        fk_pattern = r"(sa\.ForeignKeyConstraint\([^)]+\)[^,\n]*)"
        fk_matches = re.findall(fk_pattern, table_content)
        
        # Remove foreign key constraints from table definition
        new_table_content = table_content
        for fk in fk_matches:
            # Extract the constraint details for later
            col_match = re.search(r"\[([^\]]+)\].*\[([^\]]+)\]", fk)
            if col_match:
                local_cols = col_match.group(1)
                remote_cols = col_match.group(2)
                # Extract remote table
                remote_table_match = re.search(r"'\],\s*\['([^.]+)\.", fk)
                if remote_table_match:
                    remote_table = remote_table_match.group(1)
                    # Extract ondelete if present
                    ondelete_match = re.search(r"ondelete='([^']+)'", fk)
                    ondelete = f", ondelete='{ondelete_match.group(1)}'" if ondelete_match else ""
                    
                    # Create foreign key name
                    local_col_name = local_cols.strip("'")
                    fk_name = f"fk_{table_name}_{local_col_name}"
                    
                    foreign_keys.append(f"    op.create_foreign_key('{fk_name}', '{table_name}', '{remote_table}', [{local_cols}], [{remote_cols}]{ondelete})")
            
            # Remove the constraint line
            new_table_content = new_table_content.replace(fk + ',', '')
            new_table_content = new_table_content.replace(',' + fk, '')
            new_table_content = new_table_content.replace(fk, '')
        
        # Clean up extra commas
        new_table_content = re.sub(r',(\s*\n\s*\))', r'\1', new_table_content)
        
        new_tables.append(table_start + new_table_content + '\n    )')
    
    # Rebuild upgrade function
    new_upgrade = "def upgrade() -> None:\n    \"\"\"Upgrade schema.\"\"\"\n    # ### commands auto generated by Alembic - please adjust! ###\n"
    
    # Add all table creations
    for table in new_tables:
        new_upgrade += "    " + table + "\n"
    
    # Add indexes (extract from original)
    index_pattern = r'(op\.create_index\([^)]+\))'
    indexes = re.findall(index_pattern, upgrade_content)
    for index in indexes:
        new_upgrade += "    " + index + "\n"
    
    # Add foreign key constraints at the end
    if foreign_keys:
        new_upgrade += "\n    # Add foreign key constraints after all tables are created\n"
        for fk in foreign_keys:
            new_upgrade += fk + "\n"
    
    # Update downgrade function to drop foreign keys first
    downgrade_match = re.search(r'def downgrade\(\) -> None:(.*)', content, re.DOTALL)
    if downgrade_match:
        downgrade_content = downgrade_match.group(1)
        
        # Build new downgrade
        new_downgrade = "def downgrade() -> None:\n    \"\"\"Downgrade schema.\"\"\"\n    # ### commands auto generated by Alembic - please adjust! ###\n"
        
        # Drop foreign keys first
        if foreign_keys:
            new_downgrade += "    # Drop foreign key constraints first\n"
            for fk in reversed(foreign_keys):
                # Extract constraint name and table
                fk_match = re.search(r"'([^']+)',\s*'([^']+)'", fk)
                if fk_match:
                    constraint_name = fk_match.group(1)
                    table_name = fk_match.group(2)
                    new_downgrade += f"    op.drop_constraint('{constraint_name}', '{table_name}', type_='foreignkey')\n"
        
        # Add the rest of downgrade operations
        new_downgrade += "\n"
        # Extract drop operations from original
        drop_ops = re.findall(r'(op\.drop_[^(]+\([^)]+\))', downgrade_content)
        for op in drop_ops:
            new_downgrade += "    " + op + "\n"
    else:
        new_downgrade = downgrade_content
    
    # Build final content
    final_content = content[:upgrade_match.start()] + new_upgrade + "\n\n" + new_downgrade
    
    # Write output
    with open(output_file, 'w') as f:
        f.write(final_content)
    
    print(f"âœ… Fixed circular dependencies in {output_file}")
    print(f"   - Extracted {len(foreign_keys)} foreign key constraints")
    return True


if __name__ == "__main__":
    input_file = "/Users/dineshpatel/code/projects/SynapseDTE2/alembic/versions/2025_08_04_1125-48bcace70e5a_initial_database_schema.py"
    output_file = input_file  # Overwrite the same file
    
    fix_circular_dependencies(input_file, output_file)